package be.nisc.modelmappertools.editor.manager;

import be.nisc.modelmappertools.api.ClassMapping;
import be.nisc.modelmappertools.api.FieldMapping;
import org.modelmapper.ModelMapper;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.*;

public class MappingManager {

    private static final List<Class> SIMPLE_FIELDS;

    static {
        SIMPLE_FIELDS = new ArrayList<>();
        SIMPLE_FIELDS.add(String.class);
        SIMPLE_FIELDS.add(Integer.class);
        SIMPLE_FIELDS.add(Long.class);
        SIMPLE_FIELDS.add(Double.class);
        SIMPLE_FIELDS.add(Float.class);
    }

    private ClassLoader classLoader;
    private Class from, to;
    private Object modelMapper;
    private Set<FieldMapping> allFieldMappings;
    private Map<Class, Map<String, List<Method>>> methods = new HashMap<>();

    public MappingManager(ClassLoader classLoader) {
        this.classLoader = classLoader;
    }

    public void load(ClassMapping classMapping) {
        try {
            this.from = classLoader.loadClass(classMapping.from);
            this.to = classLoader.loadClass(classMapping.to);
        } catch (ClassNotFoundException e) {
            throw new RuntimeException(e);
        }

        this.allFieldMappings = classMapping.mappings;

        if (classMapping.mappings == null) {
            this.allFieldMappings = new HashSet<>();
            initializeModelMapper();
        }
    }

    private void initializeModelMapper() {
        this.modelMapper = instantiate(ModelMapper.class.getCanonicalName());
        invoke(this.modelMapper, "createTypeMap", from, to);
        Collection<Object> typeMaps = invoke(this.modelMapper, "getTypeMaps");

        typeMaps.stream().forEach(typeMap -> {
            Collection<Object> propertyMaps = invoke(typeMap, "getMappings");
            propertyMaps.stream().forEach(propertyMap -> {
                FieldMapping fieldMapping = new FieldMapping();
                fieldMapping.fromPath = calculatePath(invoke(propertyMap, "getSourceProperties"));
                fieldMapping.toPath = calculatePath(invoke(propertyMap, "getDestinationProperties"));
                fieldMapping.autoGenerated = true;
                fieldMapping.active = true;

                List<Object> destinationProperties = invoke(propertyMap, "getDestinationProperties");
                Class lastPropertyClass = invoke(destinationProperties.get(destinationProperties.size() - 1), "getType");

                fieldMapping.toType = lastPropertyClass.getCanonicalName();

                this.allFieldMappings.add(fieldMapping);
            });
        });
    }

    public Set<FieldMapping> getFieldMappings() {
        return Collections.unmodifiableSet(allFieldMappings);
    }

    public ClassMapping getOutput() {
        ClassMapping classMapping = new ClassMapping();
        classMapping.from = from.getCanonicalName();
        classMapping.to = to.getCanonicalName();
        classMapping.mappings = allFieldMappings;
        return classMapping;
    }

    public void addMapping(FieldMapping fieldMapping) {
        if (fieldMapping.autoGenerated && !allFieldMappings.contains(fieldMapping)) {
            throw new RuntimeException("Auto-generated mappings can only be created by the MappingManager");
        }

        fieldMapping.active = true;

        if (allFieldMappings.contains(fieldMapping)) {
            FieldMapping existing = allFieldMappings.stream().filter(fm -> fm.equals(fieldMapping)).findAny().get();
            fieldMapping.autoGenerated = existing.autoGenerated;
            allFieldMappings.remove(existing);
        }

        allFieldMappings.add(fieldMapping);
    }

    public void removeMapping(FieldMapping fieldMapping) {
        if (fieldMapping.autoGenerated) {
            fieldMapping.active = false;
        } else {
            allFieldMappings.remove(fieldMapping);
        }
    }

    public List<FieldInfo> getFromFields() {
        return findFieldsDeep("", "", "get", from, new ArrayList<>());
    }

    public List<FieldInfo> getToFields() {
        return findFieldsDeep("", "", "set", to, new ArrayList<>());
    }

    private List<FieldInfo> findFieldsDeep(String path, String accessPath, String direction, Class clazz, List<Class> upstreamTypes) {
        List<FieldInfo> myFields = new ArrayList<>();

        for (Field field : clazz.getDeclaredFields()) {
            String fieldPath = (path.isEmpty() ? "" : path + ".") + field.getName();
            List<FieldInfo> containedFields = null;

            String access = null;

            if (Modifier.isPublic(field.getModifiers())) {
                access = "FIELD";
            } else if (hasAccessibleMethod(field, clazz, direction)) {
                access = "METHOD";
            }

            if (access != null) {
                access = (accessPath.isEmpty() ? "" : accessPath + ".") + access;

                if (!SIMPLE_FIELDS.contains(field.getType()) && !upstreamTypes.contains(field.getType())) {
                    upstreamTypes.add(field.getType());
                    containedFields = findFieldsDeep(fieldPath, access, direction, field.getType(), upstreamTypes);
                }

                myFields.add(new FieldInfo(fieldPath, field.getType(), access, containedFields));
            }
        }

        return myFields;
    }

    private boolean hasAccessibleMethod(Field field, Class clazz, String prefix) {
        String methodName = prefix + capitalizedName(field.getName());
        Method method = null;

        try {
            if (prefix.equals("set")) {
                method = clazz.getMethod(methodName, field.getType());
            } else if (prefix.equals("get")) {
                method = clazz.getMethod(methodName);
            }
        } catch (NoSuchMethodException e) {
            // Ok then
        }

        return method != null && Modifier.isPublic(method.getModifiers());
    }

    private String capitalizedName(String name) {
        return name.substring(0, 1).toUpperCase() + name.substring(1);
    }

    private String calculatePath(List<Object> propertyInfos) {
        StringBuilder pathBuilder = new StringBuilder();

        for (int i = 0; i < propertyInfos.size(); i++) {
            pathBuilder.append(invoke(propertyInfos.get(i), "getName") + ".");
        }

        pathBuilder.setLength(pathBuilder.length() - 1);

        return pathBuilder.toString();
    }

    private <T> T instantiate(String qualifiedName) {
        try {
            return (T) classLoader.loadClass(qualifiedName).getConstructors()[0].newInstance();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    private Class getInvocationTargetType(Object target) {
        if (target.getClass().getInterfaces().length > 0) {
            return target.getClass().getInterfaces()[0];
        } else {
            return target.getClass();
        }
    }

    private <T> T invoke(Object target, String name, Object... params) {
        Class targetType = getInvocationTargetType(target);

        if (!methods.containsKey(targetType)) {
            Map<String, List<Method>> classMethods = new HashMap<>();
            methods.put(targetType, classMethods);

            for (Method method : targetType.getMethods()) {
                if (!classMethods.containsKey(method.getName())) {
                    classMethods.put(method.getName(), new ArrayList<>());
                }

                classMethods.get(method.getName()).add(method);
            }
        }

        for (Method possibleMethod : methods.get(targetType).get(name)) {
            try {
                return (T) possibleMethod.invoke(target, params);
            } catch (IllegalArgumentException e) {
                // Probably wrong overloaded method; ignore
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }

        throw new RuntimeException("Could not find proper method to invoke");
    }
}

package be.nisc.modelmappertools.maven;

import be.nisc.modelmappertools.api.ClassMapping;
import com.squareup.javapoet.*;
import org.modelmapper.ModelMapper;
import org.modelmapper.TypeMap;
import org.modelmapper.spi.DestinationSetter;
import org.modelmapper.spi.SourceGetter;

import javax.lang.model.element.Modifier;

public class MappingGenerator {
    private ClassMapping classMapping;
    private ClassName from;
    private ClassName to;


    public MappingGenerator(ClassMapping classMapping) {
        this.classMapping = classMapping;
        from = ClassName.bestGuess(classMapping.from);
        to = ClassName.bestGuess(classMapping.to);
    }

    private String capitalizedName(String name) {
        return name.substring(0, 1).toUpperCase() + name.substring(1);
    }

    public TypeSpec generateCustomMappings() {
        TypeSpec.Builder mappingsClassBuilder = TypeSpec
                .classBuilder(capitalizedName(from.simpleName()) + "To" + capitalizedName(to.simpleName()) + "Mapping")
                .addModifiers(Modifier.PUBLIC, Modifier.STATIC);

        CodeBlock.Builder registerBodyBuilder = CodeBlock.builder();

        registerBodyBuilder
                .addStatement("$T<$T, $T> typeMap = modelMapper.getTypeMap($L.class, $L.class)", TypeMap.class, from, to, from.reflectionName(), to.reflectionName())
                .addStatement("if (typeMap == null) typeMap = modelMapper.createTypeMap($L.class, $L.class)", from.reflectionName(), to.reflectionName());

        classMapping.mappings.stream().forEach(fieldMapping -> {
            if (!fieldMapping.autoGenerated) {
                TypeSpec setter = generateSourceGetter(fieldMapping.fromPath, fieldMapping.fromAccessPath);
                TypeSpec getter = generateDestinationSetter(fieldMapping.toPath, fieldMapping.toAccessPath, fieldMapping.toType);
                mappingsClassBuilder.addType(getter);
                mappingsClassBuilder.addType(setter);

                registerBodyBuilder.add("typeMap.addMappings(m -> m");

                if (fieldMapping.converter != null) {
                    registerBodyBuilder.add(".using(new $T())", ClassName.bestGuess(fieldMapping.converter));
                }

                registerBodyBuilder.addStatement(".map(new $T(), new $T()))", ClassName.bestGuess(setter.name), ClassName.bestGuess(getter.name));
            } else if (!fieldMapping.active) {
                String setPropertyName = capitalizedName(fieldMapping.toPath.substring(fieldMapping.toPath.lastIndexOf(".") + 1));
                registerBodyBuilder.addStatement("typeMap.addMappings(m -> m.skip($L::set$L))",to.reflectionName(), setPropertyName);
            }
        });

        mappingsClassBuilder.addMethod(
                MethodSpec
                        .methodBuilder("registerMappings")
                        .addModifiers(Modifier.PUBLIC)
                        .addParameter(ModelMapper.class, "modelMapper")
                        .addCode(registerBodyBuilder.build())
                        .build()
        );

        return mappingsClassBuilder.build();
    }

    private String generateName(String path, String suffix) {
        StringBuilder nameBuilder = new StringBuilder();

        for (String part : path.split("\\.")) {
            nameBuilder.append(capitalizedName(part));
        }

        nameBuilder.append(suffix);

        return nameBuilder.toString();
    }

    private TypeSpec generateSourceGetter(String fromPath, String accessPath) {
        String name = generateName(fromPath, "SourceGetter");

        StringBuilder bodyBuilder = new StringBuilder("return target.");

        String[] pathSplit = fromPath.split("\\.");
        String[] accessPathSplit = accessPath.split("\\.");

        for (int p = 0; p < pathSplit.length; p++) {
            if (accessPathSplit[p].equals("FIELD")) {
                bodyBuilder.append(pathSplit[p]).append(".");
            } else if (accessPathSplit[p].equals("METHOD")) {
                bodyBuilder.append("get").append(capitalizedName(pathSplit[p])).append("().");
            }
        }

        bodyBuilder.setLength(bodyBuilder.length() - 1);

        TypeSpec getter = TypeSpec.classBuilder(name)
                .addSuperinterface(ParameterizedTypeName.get(ClassName.get(SourceGetter.class), from))
                .addModifiers(Modifier.PUBLIC)
                .addMethod(
                        MethodSpec
                                .methodBuilder("get")
                                .addModifiers(Modifier.PUBLIC)
                                .addParameter(from, "target")
                                .addStatement(bodyBuilder.toString())
                                .returns(Object.class)
                                .build()
                )
                .build();

        return getter;
    }

    private TypeSpec generateDestinationSetter(String toPath, String accessPath, String toType) {
        String[] pathSplit = toPath.split("\\.");
        String[] accessPathSplit = accessPath.split("\\.");

        String name = generateName(toPath, "DestinationSetter");

        StringBuilder bodyBuilder = new StringBuilder("target.");

        for (int x = 0; x < pathSplit.length; x++) {
            if (x < pathSplit.length - 1) {
                if (accessPathSplit[x].equals("FIELD")) {
                    bodyBuilder.append(pathSplit[x]).append(".");
                } else if (accessPathSplit[x].equals("METHOD")) {
                    bodyBuilder.append("get").append(capitalizedName(pathSplit[x])).append("().");
                }
            } else {
                if (accessPathSplit[x].equals("FIELD")) {
                    bodyBuilder.append(pathSplit[x]).append(" = value");
                } else if (accessPathSplit[x].equals("METHOD")) {
                    bodyBuilder.append("set").append(capitalizedName(pathSplit[x])).append("(value)");
                }
            }
        }

        TypeSpec setter = TypeSpec.classBuilder(name)
                .addSuperinterface(ParameterizedTypeName.get(ClassName.get(DestinationSetter.class), to, ClassName.bestGuess(getClassType(toType))))
                .addModifiers(Modifier.PUBLIC)
                .addMethod(
                        MethodSpec
                                .methodBuilder("accept")
                                .addModifiers(Modifier.PUBLIC)
                                .addParameter(to, "target")
                                .addParameter(ClassName.bestGuess(getClassType(toType)), "value")
                                .addStatement(bodyBuilder.toString())
                                .build()
                )
                .build();

        return setter;
    }

    private String getClassType(String type) {
        if (type.equals("int")) {
            return "java.lang.Integer";
        } else {
            return type;
        }
    }
}
